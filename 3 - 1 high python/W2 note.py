# set
# 순서가 없기 때문에 인덱스를 통한 특정 원소 접근 불가
# 중복 없음
s1 = {1, 2, 3}
print(type(s1))

# list
# 인덱스 사용 가능
# 중복 원소 가능
# 다양한 함수 사용 가능
# listt = [1, 2, 3, [6, 8]]
# 리스트 안에 또 리스트 가능
s2 = [1, 2, 3]
print(type(s2))

# tuple
# 인덱싱, 슬라이싱 가능
# 요소 수정 불가
# 튜플 속에 튜플 가능
# zip 함수를 원소 개수가 동일한 크기의 자료형에 사용하는 경우 튜플을 원소로 하는 자료구조가 만들어짐
# +, * 연산 가능 : 더하면 튜플이 이어지고 곱하면 튜플이 반복됨. 산술적 연산 아님!
s3 = (1, 2, 3)
print(type(s3))
s4 = 1, 2, 3
print(type(s4))

# dictionary
# key는 변경 불가, value는 변경 가능
# s5[1] 로 value에 접근 가능
# 다양한 함수 사용 가능
s5 = {1: 100}  
print(type(s5))


# 패킹과 언패킹
# 패킹 : 하나의 변수에 여러 가지 값을 포장
# 언패킹 : 여러 가지 값을 가진 하나의 변수를 여러 변수로 나눔
# _ : 필요 없는 값을 받아 넘기는 데 사용, 숫자의 자리 구분에도 사용 가능
# * : 들어오는 값이 변수의 개수보다 많을 때, 다른 변수에 주고 남은 값을 모두 받아옴
# 예시
lis1 = [1, 2, "tea", 3]
a1, b1, _, c1 = lis1  # _에 "tea"가 저장됨
print(_)  # tea 출력

lis2 = [1, 2, 3, 4, 5, "apple", "tea"]
a2, b2, *_, c2 = lis2  # *이 붙었기 때문에 다른 변수에 할당하고 남은 값이 전부 _에 리스트로 저장됨
print(_)
print(c2)


# 컴프리헨션
# 조건식을 이용하여 한 컨테이너로부터 변형된 다른 컨테이너를 만들 수 있음
# 기본 용법 : 새_변수명 = [출력표현식 for 카운트요소 in 입력값컨테이너 if 조건식]
# 대괄호인지 중괄호인지는 만들고 싶은 변수가 리스트인지 집합인지 딕셔너리인지에 따라 다름
# 예시
comp_lis = [1, 2, 3, 4, 5, "apple", "tea", "mint"]
comp_set = {i * i for i in comp_lis if type(i) == int}  # 집합이라 요소 순서는 랜덤임
comp_dic = {"dog" : "개", "cat" : "고양이", "human" : "휴먼"}
comp_new_dic = {val : key for key, val in comp_dic.items()}  # 키와 값이 반대로 저장됨


# 숫자 변수에 사용된 밑줄 예시
underbar_number1 = 1_000_000_000  # 10진수
underbar_number2 = 0b_0011  # 2진수
underbar_number3 = 0o_0011  # 8진수
underbar_number4 = 0x_00_11  # 16진수


# 에외 처리 분기문
# 기본 구조
try:
    # 예외가 발생할 수 있는 코드
    pass
except:
    # 예외가 발생했을 때 실행할 코드
    # except ValueError: 처럼 오류 타입을 지정할 수 있으며 파이참에서는 이를 권장한다.
    pass
else:
    # 예외가 발생하지 않았을 때 실행할 코드
    pass
finally:
    # 예외 여부에 관계 없이 무조건 실행할 코드
    pass
